/**\n * Export des utilitaires et classes pour les exemples\n * Facilite la réutilisation du code entre exemples\n */\n\nimport { CoinGeckoProvider } from '../src/providers/coingecko.js';\nimport { VolatilityCalculator } from '../src/calculators/volatility.js';\nimport { DVOLCalculator } from '../src/calculators/dvol.js';\nimport type {\n  CryptoSymbol,\n  TimePeriod,\n  DVOLMethod,\n  VolatilityMetrics,\n  PriceData,\n} from '../src/types.js';\n\n/**\n * Classe utilitaire pour formater les résultats\n */\nexport class ResultFormatter {\n  /**\n   * Formate un pourcentage\n   */\n  static formatPercentage(value: number, decimals: number = 2): string {\n    return `${value.toFixed(decimals)}%`;\n  }\n\n  /**\n   * Formate un nombre\n   */\n  static formatNumber(value: number, decimals: number = 2): string {\n    return value.toFixed(decimals);\n  }\n\n  /**\n   * Formate une date\n   */\n  static formatDate(date: Date): string {\n    return date.toLocaleString('fr-FR');\n  }\n\n  /**\n   * Affiche un séparateur principal\n   */\n  static separator(title: string): void {\n    console.log(`\\n${'='.repeat(60)}`);\n    console.log(`  ${title}`);\n    console.log(`${'='.repeat(60)}\\n`);\n  }\n\n  /**\n   * Affiche un sous-titre\n   */\n  static subsection(title: string): void {\n    console.log(`\\n→ ${title}`);\n    console.log(`${'-'.repeat(40)}`);\n  }\n\n  /**\n   * Affiche un résultat avec clé-valeur\n   */\n  static result(label: string, value: string | number): void {\n    const formatted = typeof value === 'number' ? value.toFixed(2) : value;\n    console.log(`  ${label.padEnd(30)}: ${formatted}`);\n  }\n\n  /**\n   * Affiche une liste numérotée\n   */\n  static list(items: string[]): void {\n    items.forEach((item, idx) => {\n      console.log(`  ${idx + 1}. ${item}`);\n    });\n  }\n\n  /**\n   * Affiche un message de succès\n   */\n  static success(message: string): void {\n    console.log(`\\n✓ ${message}\\n`);\n  }\n\n  /**\n   * Affiche un message d'erreur\n   */\n  static error(message: string): void {\n    console.error(`\\n✗ ${message}\\n`);\n  }\n\n  /**\n   * Affiche un avertissement\n   */\n  static warning(message: string): void {\n    console.log(`\\n⚠ ${message}\\n`);\n  }\n}\n\n/**\n * Classe wrapper pour faciliter l'utilisation\n */\nexport class VolatilityAnalyzer {\n  private provider: CoinGeckoProvider;\n\n  constructor() {\n    this.provider = new CoinGeckoProvider();\n  }\n\n  /**\n   * Analyse complète d'une crypto\n   */\n  async analyze(\n    crypto: CryptoSymbol,\n    period: TimePeriod,\n    dvolMethod: DVOLMethod = 'ewma'\n  ) {\n    try {\n      // Récupérer les données\n      const response = await this.provider.fetchPriceData(crypto, period);\n\n      if (!response.success || !response.data) {\n        throw new Error(response.error || 'Failed to fetch price data');\n      }\n\n      const priceData = response.data;\n      const prices = priceData.map(d => d.price);\n\n      // Calculer les métriques\n      const volatility = VolatilityCalculator.calculateMetrics(priceData, period);\n      const dvol = DVOLCalculator.calculateDVOL(priceData, dvolMethod);\n      const diagnostics = DVOLCalculator.calculateDiagnostics(priceData, dvolMethod);\n\n      // Statistiques des prix\n      const minPrice = Math.min(...prices);\n      const maxPrice = Math.max(...prices);\n      const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;\n\n      return {\n        crypto,\n        period,\n        dataPoints: priceData.length,\n        prices: {\n          min: minPrice,\n          max: maxPrice,\n          avg: avgPrice,\n          range: maxPrice - minPrice,\n          rangePercent: ((maxPrice - minPrice) / minPrice) * 100,\n        },\n        volatility,\n        dvol,\n        diagnostics,\n      };\n    } catch (error) {\n      throw new Error(\n        `Analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Compare deux cryptos\n   */\n  async compare(\n    crypto1: CryptoSymbol,\n    crypto2: CryptoSymbol,\n    period: TimePeriod,\n    dvolMethod: DVOLMethod = 'ewma'\n  ) {\n    const [result1, result2] = await Promise.all([\n      this.analyze(crypto1, period, dvolMethod),\n      this.analyze(crypto2, period, dvolMethod),\n    ]);\n\n    return {\n      result1,\n      result2,\n      comparison: {\n        dvolDifference: Math.abs(result1.dvol.dvol - result2.dvol.dvol),\n        percentageDifference:\n          ((Math.abs(result1.dvol.dvol - result2.dvol.dvol) /\n            Math.min(result1.dvol.dvol, result2.dvol.dvol)) *\n            100),\n        moreVolatile: result1.dvol.dvol > result2.dvol.dvol ? crypto1 : crypto2,\n      },\n    };\n  }\n\n  /**\n   * Analyse plusieurs cryptos\n   */\n  async analyzeMultiple(\n    cryptos: CryptoSymbol[],\n    period: TimePeriod,\n    dvolMethod: DVOLMethod = 'ewma'\n  ) {\n    const results = await Promise.all(\n      cryptos.map(crypto => this.analyze(crypto, period, dvolMethod))\n    );\n\n    const sorted = results.sort((a, b) => b.dvol.dvol - a.dvol.dvol);\n\n    return {\n      results: sorted,\n      ranking: sorted.map((r, idx) => ({\n        rank: idx + 1,\n        crypto: r.crypto,\n        dvol: r.dvol.dvol,\n        index: r.dvol.dvolIndex,\n      })),\n      statistics: {\n        maxDvol: Math.max(...results.map(r => r.dvol.dvol)),\n        minDvol: Math.min(...results.map(r => r.dvol.dvol)),\n        avgDvol: results.reduce((sum, r) => sum + r.dvol.dvol, 0) / results.length,\n      },\n    };\n  }\n\n  /**\n   * Détecte les anomalies dans les données\n   */\n  async detectAnomalies(\n    crypto: CryptoSymbol,\n    period: TimePeriod,\n    threshold: number = 2\n  ) {\n    const response = await this.provider.fetchPriceData(crypto, period);\n\n    if (!response.success || !response.data) {\n      throw new Error(response.error);\n    }\n\n    const prices = response.data.map(d => d.price);\n    const logReturns = VolatilityCalculator.calculateLogReturns(prices);\n\n    const mean = VolatilityCalculator.calculateMean(logReturns);\n    const std = VolatilityCalculator.calculateStandardDeviation(logReturns);\n\n    const anomalies = logReturns\n      .map((r, idx) => ({\n        return: r,\n        index: idx,\n        zscore: Math.abs((r - mean) / std),\n        timestamp: response.data![idx + 1].timestamp,\n      }))\n      .filter(a => a.zscore > threshold)\n      .sort((a, b) => b.zscore - a.zscore);\n\n    return {\n      crypto,\n      period,\n      threshold,\n      anomalies,\n      count: anomalies.length,\n      percentage: (anomalies.length / logReturns.length) * 100,\n    };\n  }\n}\n\n// Export des classes principales\nexport { CoinGeckoProvider, VolatilityCalculator, DVOLCalculator };\n"